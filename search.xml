<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Docker搭建隔离开发环境]]></title>
    <url>%2F2019-04-19-docker-env%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp; 最近接触到了Docker相关的知识，了解了它的相关特性，并基于它搭建了一些如mysql/redis/mq作为一个后端开发所必须的的环境，为什么使用Docker来搭建，听我娓娓道来。&emsp;&emsp; 梦回到刚学后端的时候，你需要搭建个mysql环境，然后你去搜了下windows mysql 环境搭建，得到了一种叫绿色版安装，一种叫傻瓜式（安装包）式安装，一顿操作之后我们的电脑终于多了一个mysql的服务，然后使用Navicat成功连接上了，开始沾沾自喜。&emsp;&emsp;一个月后，由于某种原因（可能你删了mysql包的哪个文件）你需要把mysql重装一下，于是乎你又去搜了下windows mysql 卸载，你惊喜的得到了这么一个结果&emsp;&emsp;WTF？彻底卸载可还行，于是你花了比安装更多的力气去卸载了一个mysql。&emsp;&emsp;工作一年之后，你回想起你的这波操作，不禁笑了起来，你看着现在的vmware+centOS虚拟机中挂着的mysql+redis环境不禁沾沾自喜，虚拟机中的开发环境与本机完全隔离，哪天我不要环境了直接把虚拟机卸了就行，真是一个很完美的配置呢~&emsp;&emsp;但是，你似乎忘记了，你花费了多大的力气踩了多少的坑才折腾好你这套环境，想到这你不禁为自己留下心疼的眼泪。&emsp;&emsp;这套环境支撑你跑了很久，在此之间你还学会了很多linux的常规指令，成为了一个运维小能手，有一天你在逛社区的时候看到一篇文章叫做使用 Docker 快速搭建开发环境，能有多“快”，我得去瞅瞅，跟着它敲了一遍代码，mysql，它，起来了。&emsp;&emsp;我告诉自己，我得去看看这东西，它是个什么妖魔鬼怪。 Docker介绍&emsp;&emsp;Docker于2013年发布， 属于 Linux 容器的一种封装，提供简单易用的容器使用接口，可以轻易的使用/制作一个镜像（带有环境的容器）。具体详细的介绍网上有太多了，这里就不赘述了。 环境搭建Windows Docker环境搭建&emsp;&emsp;环境搭建的文章也很多，我这里主要说一下可能会踩到的坑，docker针对windows的用户主要有两个安装包可以下载，我们可以在阿里云平台看到关于安装的Docker的一些建议，具体区别可以参考这篇博客dockerToolbox和docker for windows的区别，本文主要讲一下Docker for Windows的安装流程。 Docker Toolbox：Docker工具集安装器 Docker for Windows：Windows平台的Docker安装 进入https://www.docker.com/products/docker-desktop 下载Docker for Windows安装包； 执行Docker for Windows安装程序，一路next，Docker运行成功后会有通知且右下角有logo图标存在； 没了，Docker这就算安装好了，使用PowerShell或者cmd执行命令试试 Docker安装完成后，由于它需要Hyper-V的支持，这会与VMware的虚拟机启动产生冲突报错如下，具体原因请参考Docker 和 vmware 共存工作 熟悉一下基本流程&emsp;&emsp;在这个阶段我们使用Docker拉取一个集成了SSH服务的centOS7系统镜像，将它运行起来并使用Xshell远程连接做一些基本的linux操作 # docker pull 拉取镜像指令# jdeathe/centos-ssh代表镜像名称 centos-7代表镜像标签（版本）不填取最新latest# 具体镜像信息查看 https://hub.docker.com/docker pull jdeathe/centos-ssh:centos-7# docker images 查看已经拉取的镜像列表docker images# docker run 将镜像构建成容器# -d 分离运行 不会在命令行打印容器运行日志# --name 指定容器名称# -p 2020:22 将本机的2020端口映射到容器的22端口# --env 设置容器支持的环境配置# jdeathe/centos-ssh:centos-7 镜像名称docker run -d --name centos-ssh -p 2020:22 --env SSH_PASSWORD_AUTHENTICATION=true --env SSH_USER=admin --env SSH_USER_PASSWORD=123456 jdeathe/centos-ssh:centos-7# docker inspect 查看指定容器的详细信息 centos-ssh是刚刚指定的容器名称docker inspect centos-ssh# docker ps 查看容器信息 运行成功则会显示在列表中docker ps# 使用XShell进入容器 locahost:2020 admin/123456 &emsp;&emsp;成功连接上容器并执行了一些基础操作 &emsp;&emsp;除去不必要的打印信息指令，我们只需要使用两行代码即可创建一个centOS系统镜像容器 可视化界面&emsp;&emsp;指令操作虽然能让你更加熟练且装逼，但它总是繁琐的，Docker官方及周边提供了很多基于Docker指令的傻瓜式UI程序，在这里我主要介绍两款 Kitematic GUI程序&emsp;&emsp;Kitematic是由Docker官方提供的一款桌面应用，提供了Windows平台下的绿色版压缩包，使用起来非常简单。 前往Kitematic的github releases仓库下载Kitematic-XXX-Windows.zip； 解压直接运行 Kitematic.exe，界面如下 点击一个容器可进入详情页面 点击Settings进入配置页面 Portainer Web程序&emsp;&emsp;Portainer是一个轻量级的管理界面，可以让您轻松地管理不同的Docker环境，功能比Kitematic强大许多。 &emsp;&emsp;Portainer是基于网页来操作的，本质上是一个B/S架构的程序，它有单独的镜像发布在Docker中，所以它的使用也非常便捷，我们只需要拉取镜像运行即可。 # 拉取最新的portainer镜像docker pull portainer/portainer# --restart=always 代表容器总是随着Docker启动而启动# -v 配置持久化路径docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name portainer portainer/portainer# 检查服务运行状态docker ps# 正常情况下服务已经运行在 http://localhost:9000 进入 http://localhost:9000/#/init/admin ， 进行管理员配置； 初始化Docker端点配置http://localhost:9000/#/init/endpoint ， 需要配合在Docker配置开启Web Api服务； 进入Portainer主页，查看相关配置 开发集成环境搭建&emsp;&emsp;在有了前面环境的铺垫之后，现在可以很轻易就搭建好我们所需要的开发环境，具体操作无非是 找到所需的镜像及版本，拉取镜像 根据镜像描述做好配置并启动 测试环境是否可用 mysql&emsp;&emsp;任意找一个GUI程序搜索到所需的镜像，拉取运行即可 &emsp;&emsp;关于mysql连接密码可在环境变量中配置重启 &emsp;&emsp;使用Navicat测试连接是否可用，这里主要要看镜像与宿主机器的端口映射表，使用 localhost:3306 root/123456 即可连接上mysql，环境搭建成功 redis&emsp;&emsp;使用Kitematic搜索redis相关镜像，点击创建，使用RedisDesktopManager进行测试，默认是没有密码验证的模式，如果需要更改可以进入容器内部修改，这部分操作我会在后续的博客整理 rabbitmq&emsp;&emsp;其他的环境操作都是类似的，当然如果没有搜索你想要的镜像（比如你想要一个mysql+redis的镜像），可以自己构建发布，在此之前你可能需要注册一个Docker账号 其他配置Docker镜像加速&emsp;&emsp;注册一个阿里云账号，进入控制台-&gt;容器镜像服务-&gt;镜像中心-&gt;镜像加速器，获取到加速器的地址，复制到Docker的Settings/Daemon中，重启Docker即可。 参考资料Windows 10 安装Docker for Windows - 晓晨Master - 博客园使用 Docker 快速搭建开发环境dockerToolbox和docker for windows的区别- Null的博客- CSDN博客Docker 和 vmware 共存工作 - rodert - CSDN博客Docker各种可视化界面的比较]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>mysql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客可以自己部署啦]]></title>
    <url>%2F2019-03-07-blog-with-jenkins%2F</url>
    <content type="text"><![CDATA[我的自动化运维平台已经成功上线啦~ 博客可以自己照顾自己啦~ 本篇博客用于测试自动化运维平台是否正常运行 在我写完这篇博客执行以下脚本后 git add .git commit -m"自动部署测试"git push origin master 这时候对话开始了 github：jenkins兄弟，快起来，该干活了 Jenkins看看来的任务，blogs，ok，i know jenkins：包在我身上# 拉取代码git clone https://github.com/calebman/blog.git# 打印版本node -vnpm -v# 安装hexo-cli脚手架npm install -g hexo-clihexo -v# 安装依赖npm i# 打包博客hexo cleanhexo g# 将打包文件移动到服务器的指定目录 nginx配置目录cp -rf public/* /home/app/application/blogs/# 部署到 github.iohexo d jenkins：发封邮件给主人告诉他我干完了 盯 看看手机，好的看来博客已经上线了 访问http://blog.chenjianhui.site试试 有了，jenkins辛苦辣，下次给你换个更好的服务器环境 测试成功Ending~]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离模式下的DevOps]]></title>
    <url>%2F2019-03-01-devops-practice%2F</url>
    <content type="text"><![CDATA[背景概述理解Devops&emsp;&emsp; 维基百科对Devops的定义是：一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 &emsp;&emsp;自动化运维以及持续集成部署是Devops的核心思想，当你发现自己每天花费了大量的时间在等待程序打包/上传至服务器等过程中时，你就应该思考，是否需要将这些重复性的行为交给机器去做，来解放自己花费在这部分的时间。 我为何要引入Devops背景简介&emsp;&emsp;楼主是一个常年在二三线城市小公司漂泊的苦逼程序员，小公司的特性就是一人当三人使，一个人兼做开发测试加运维，公司采用敏捷开发模式，现有平台4套，大部分都是前后端分离的系统，由于功能调整的比较快导致部署演示的频次非常高，最多会出现一天部署10次左右，再加上ssh文件上传与webpack的打包程序的运行时间较长，最快的本地打包+ssh上传+启动远程运行脚本的流程走下来也得5min左右，所以光部署这一块花费的人力成本已经不可忽略了。 应用架构简介&emsp;&emsp;楼主公司的web应用主要采用SpringBoot+Vuejs前后端分离开发模式，打包后的应用由Nginx来动静内容分发，应用架构的详情可见我的另一篇博客前后端分离开发模式的实践总结，源代码获取点击这里，本文也将围绕着这个结构的工程来做自动化部署。 冲突与问题 等待程序打包时间过长（特别是webpack的打包），大部分时间在等待，这件事在进行中也不好做别的事情 重复性劳动过多，每次打包都是运行打包脚本，上传打包后的文件夹，运行远程启动脚本 容易出错，假设现有的环境是两套（演示与生产），那么远端运行脚本需要根据环境的不同来传递不同的环境变量，人为错误极易发生 理想环境 程序员提交代码至dev分支，此时触发演示环境的打包部署程序 技术老大提交代码至master分支，此时触发生产环境的打包部署程序 打包成功/失败/中断通知到钉钉工作群 Devops实践Windows10环境搭建 java：JDK开发环境搭建及环境变量配置 tomcat：Windows安装和配置Tomcat git：Git安装教程 jenkins 点此下载jenkins的war包 将jenkins.war复制到tomcat服务器的webapps目录下 配置jenkins的工作目录，在我的电脑-属性-高级系统设置-环境变量-添加系统变量JENKINS_HOME，内容是一个空的文件夹，作为jenkins的工作目录。如果不想设置系统环境变量也可以修改加载有jenkins.war的tomcat目录下的conf\context.xm文件，如下设置JENKINS_HOME 访问jenkins的主页http://localhost:8080/jenkins &lt;!-- tomcat context.xml 环境变量设置 --&gt;&lt;Context&gt; &lt;!-- 设置jenkins的工作目录 --&gt; &lt;Environment name="JENKINS_HOME" value="C:/jenkins/" type="java.lang.String"/&gt;&lt;/Context&gt; CentOS7.3环境搭建&emsp;&emsp;在CentOS7下搭建jenkins和Windows环境差不多，jenkins是一个依赖于web容易的war包，所以只要有java与tomcat环境即可 git环境# 判断git是否已存在 打印内容则代表存在git --version# 不存在则安装 出现complete说明安装成功yum install -y git jdk环境 jdk1.8下载：点此下载 解压配置 mkdir /usr/java# 使用Xftp将下载的jdk放到此目录cd /usr/java# 解压jdktar -zxvf jdk-8u201-linux-x64.tar.gz # 修改配置文件vim /etc/profile# 文件末尾添加java的环境变量JAVA_HOME=/usr/java/jdk1.8.0_201JRE_HOME=/usr/java/jdk1.8.0_201/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH# 使得配置生效source /etc/profile# 测试配置java -version tomcat环境 tomcat8下载：点此下载 解压配置 # 使用Xftp将下载的tomcat放到此目录mkdir /usr/tomcatcd /usr/tomcat# 解压tomcattar -zxvf apache-tomcat-8.5.38.tar.gz # 测试运行cd apache-tomcat-8.5.38sh bin/startup.sh# 检测服务是否成功启动 打印了进程即说明启动成功netstat -nlp|grep 8080# 稍微清理一下tomcat 删除没有用的项目rm -rf /usr/tomcat/apache-tomcat-8.5.38/webapps/*# 配置自动启动 /etc/rc.d/init.d 为启动运行脚本的目录cd /etc/rc.d/init.d# 创建自启动脚本touch tomcat# 写入脚本信息vim tomcat# 脚本信息如下 以下注释信息也需要复制进脚本文件 # 如果缺少了chkconfig:234 20 80这个注释会报错无法识别为自启脚本#!/bin/sh#chkconfig:234 20 80 #description:tomcatJAVA_HOME=/usr/java/jdk1.8.0_201export JAVA_HOMEPATH=$JAVA_HOME/bin:$PATH export PATHtomcat_path=/usr/tomcat/apache-tomcat-8.5.38/bincase "$1" in start) echo "start tomcat service.." sh $&#123;tomcat_path&#125;/startup.sh ;; *) exit 1 ;;esac# 赋予权限chmod 755 tomcat# 注册tomcat服务自启chkconfig --add tomcat# 测试服务是否能够自启 先停止运行中的tomcatsh /usr/tomcat/apache-tomcat-8.5.38/bin/shutdown.shservice tomcat startnetstat -nlp|grep 8080# 查看所有注册自启的服务chkconfig jenkins环境 jenkins下载：点此下载 配置 mkdir /usr/jenkins# 使用Xftp将下载的tomcat放到此目录cd /usr/jenkins# 复制jenkins.war至tomcat/webapps目录cp jenkins.war /usr/tomcat/apache-tomcat-8.5.38/webapps# jenkins.war会自动解包启动 进入tomcat/webapps目录查看 jenkins.war已经解包成了文件夹cd /usr/tomcat/apache-tomcat-8.5.38/webappsls# 修改tomcat环境配置将jenkins的工作目录切换至/home/app/jenkinsvi /usr/tomcat/apache-tomcat-8.5.38/conf/context.xml# Context标签下添加以下内容&lt;Environment name="JENKINS_HOME" value="/home/app/jenkins" type="java.lang.String"/&gt;# 重启tomcatcd /usr/tomcat/apache-tomcat-8.5.38sh bin/shutdown.shsh bin/startup.sh# 检查工作目录切换是否成功 有文件即成功cd /home/app/jenkins# 清空原先的工作空间 jenkins默认工作空间为 /root/.jenkinsrm -rf /root/.jenkins 配置JenkinsJenkins的初始化 第一次进入jenkins时会要求使用初始密码解锁，按照提示操作就行了 之后会提示你安装插件，在这里我们采用默认安装必要的插件即可，其他的插件我们可以在系统内部再去安装 耐心等待插件安装完毕 初始化完成，配置管理员用户 配置jenkins实例地址，举个例子解释实例配置的地址用处 假设你做了项目打包成功或者失败的通知，jenkins构建的默认通知信息里会带有一个进入系统的链接地址，方便用户直接从邮件/钉钉等地方进入系统查看构建详情，这个地址即是此处配置的实例地址 所有配置完成后，成功进入系统 Jenkins的环境配置环境需求分析 拉取远端master分支代码：Git插件 运行前端打包脚本：Nodejs环境 运行后端打包脚本：Java环境+Maven插件 推送装有构建代码的文件夹：SSH文件传输插件 运行远程启动脚本：SSH脚本运行插件 配置插件&emsp;&emsp;对应jenkins/系统管理/插件管理目录，根据上述的打包流程得出插件需求，在baidu/google搜索得到jenkins上对应的插件名称，选择并安装它们。 插件的选择 Publish Over SSH：基于SSH协议的文件上传插件 Nodejs：nodejs运行环境 Dingding：钉钉推送通知 Maven Integration：Maven插件 插件的安装 进入jenkins-系统管理-插件管理 选择available（可选插件）标签 搜索出以上选择的插件，勾选之后点击直接安装 配置全局工具&emsp;&emsp;对应jenkins/系统管理/全局工具配置目录，主要是配置打包所需的环境，如Java/Git/Maven等等，如果系统自带环境可以填写系统环境，如果没有可以采用jenkins自动安装的方式。 JDK配置 tips：如果找不到java的安装目录可以使用 which java 查看 Git配置 tips：如果找不到git的安装目录可以使用 which git 查看 Maven配置 NodeJS配置 配置文件管理&emsp;&emsp;对应jenkins/系统管理/Managed files目录，主要是管理自定义的配置文件，如Maven的settings.xml，Npm的npmrc.config文件等等，我们在这主要配置一下Maven和Npm的仓库镜像，使其切换到国内的阿里云的Maven镜像和淘宝的Npm镜像。 Maven settings.xml &emsp;&emsp;新增Maven settings.xml配置文件，在mirrors标签下添加以下配置&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; Npm config file &emsp;&emsp;新增Npm config file配置文件，修改registry的配置registry=https://registry.npm.taobao.org 配置全局凭据&emsp;&emsp;对应jenkins/凭据/系统/全局凭据目录，主要是用于添加如gitlab/ssh等受限访问应用的信任凭据。 其他配置 Publish over SSH插件 &emsp;&emsp;该插件的配置在jenkins/系统管理/系统设置目录，主要的配置如下： &emsp;&emsp;高级配置下还可以配置SSH端口，重置默认设置等等，这里不做过多讲解 Dingding通知使用 &emsp;&emsp;钉钉通知的配置在任务的配置项中，配置起来较为简单（比微信通知简单太多）只需要两步操作。 （1）获取钉钉通知自定义机器人webhook的access_token，点此进入钉钉开放平台获取配置帮助 （2）在任务中配置通知 &emsp;&emsp;通知效果如图，点击即可进入jenkins管理平台查看详情 Jenkins的任务配置&emsp;&emsp;至此基于一个前后端分离项目的自动打包配置已经基本完成，现在我们使用jenkins构建一个任务来测试配置是否成功，本次构建任务是基于我的一个开源模板项目server-front-separate来进行。 新建任务&emsp;&emsp;进入jenkins根目录点击新建任务 &emsp;&emsp;任务新建成功 任务基础配置&emsp;&emsp;本次的基础配置我们需要达到任务能够自动化打包的效果，为达到此效果我们至少需要配置以下几项内容： 源码管理 构建环境 后端构建步骤 前端构建步骤 源码管理 构建环境 后端构建步骤 前端构建步骤 linux环境下采用Shell脚本构建，换行分割指令 cd front/node -vnpm -vnpm inpm run build Windows环境下采用批处理脚本构建，使用&amp;与&amp;&amp;来连接指令，&amp;代表下一条指令必定执行，&amp;&amp;代表当上一条指令出现错误下一条指令不执行 cd front/ &amp; node -v &amp; npm -v &amp; npm i &amp;&amp; npm run build 构建运行&emsp;&emsp;基础配置完成后，我们进入项目主页进行一次构建测试 &emsp;&emsp;构建成功后进入任务的工作空间，可以查看到项目已经打包成功，项目的目录结构描述详见我的另一篇博客前后端分离开发模式的实践总结 Jenkins任务自动化&emsp;&emsp;至此项目已经能够通过jenkins平台来进行打包操作了，但是这还远远没达到自动化的概念，我们的目标是通过git代码提交操作来触发构建并且自动部署到生产/演示服务器上，所以接下来进行自动化的配置工作 自动构建&emsp;&emsp;自动构建是指通过Git服务器的Webhooks来触发Jenkins的打包构建流程，在这里我们将实现以下流程： 更新代码至github项目的master分支 jenkins开始构建代码 &emsp;&emsp;jenkins默认对github的webhook有支持使得这个流程的配置非常简单，jenkins的webhook触发地址为${JENKINS_URL}/github-webhook/，其中JENKINS_URL为jenkins服务在公网的根目录地址，可以在jenkins/系统管理/系统设置处修改此默认地址 &emsp;&emsp;得到Webhook地址后我们只需要在github的项目Settings选项卡上添加此地址即可，github默认触发Webhook的逻辑是push代码时即触发 &emsp;&emsp;当然，别忘记了在jenkins的任务中勾选Github hook触发构建 自动部署&emsp;&emsp;自动部署是指在代码构建完成后将生成的发布代码推送到远程服务器中并启动它们，流程如下： 代码构建成功后上传打包目录 运行远程脚本重启服务 &emsp;&emsp;上文我们讲到Publish Over SSH这个插件能够远程推送代码并运行脚本，自动部署的功能即依赖此插件，配置如下： # 定义脚本执行地址export COMMAND_PATH=/home/app/application/server-front-separate/bin# 将所有脚本文件转换为UNIX格式sed -i 's/\r//' $COMMAND_PATH/*.sh# 停止服务sh $COMMAND_PATH/stop.sh test# 启动服务sh $COMMAND_PATH/start.sh test 构建通知&emsp;&emsp;在这里我们使用钉钉来做通知功能，钉钉通知的配置在上文已经介绍过了，通知的的类型有四种，我们需要哪种类型的通知直接勾选即可，四种通知类型正好对应jenkins任务构建的三种状态： 成功：构建步骤与构建后的操作全部成功，对应构建成功时通知 失败：构建步骤失败，对应构建失败时通知 不稳定：构建步骤成功但构建后的操作存在失败的情况，对应构建中断时通知 常见问题中文乱码&emsp;&emsp;在jenkins/系统管理/系统设置中添加全局属性： 参考资料Jenkins——应用篇——插件使用——Publish over SSHjenkins 集成钉钉机器人Jenkins之解决乱码问题Jenkins与Github集成 webhook配置]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>maven</tag>
        <tag>nodejs</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前后端分离开发模式的实践总结]]></title>
    <url>%2F2019-02-23-server-front-separate%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp; 实践前后端分离的开发模式已经有两年左右的时间了，对于前后端分离开发模式的概念在这里不做过多解释，本文主要是总结开发模式并构建一个较为成熟的前后端分离应用 技术选型&emsp;&emsp; 关于技术选型方面线下国内比较流行的主要是SpringBoot+Vuejs这个技术栈，所以本文将基于这个技术栈来讲解，涉及到的技术主要有 环境 Java Maven Nodejs Nginx 前端 vue-cli 后端 SpringBoot 环境准备&emsp;&emsp; 这里简要引用Windows下的环境搭建，关于Linux(Centos7)的环境搭建会再部署架构中讲到 Java : JDK开发环境搭建及环境变量配置 Maven :Maven开发环境搭建 Nodejs :NodeJS、NPM安装配置与测试步骤(windows版本) Nginx :windows下nginx的安装及使用 构建前后端分离工程目录规划&emsp;&emsp;整体目录主要分为三块，如下所示 &emsp;&emsp;打包后的目录主要分为三块，如下所示 后端工程&emsp;&emsp;后端工程主要基于SpringBoot脚手架搭建，SpringBoot基础的集成环境搭建可以参考我的另一篇博客SpringBoot集成环境搭建 &emsp;&emsp;首先创建一个只有Web功能的SpringBoot项目，修改其maven打包的配置实现以下两个功能 将打包的jar文件移动至dist目录下 将多环境配置文件从jar内部移动至外部的dist/config目录下 &emsp;&emsp;此项修改主要依赖于以下两个maven插件 maven-resources-plugin maven-antrun-plugin &emsp;&emsp;详细的插件配置如下，在server/pom.xml的plugins标签下添加如下代码&lt;!--复制配置文件--&gt;&lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-resources&lt;/id&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.basedir&#125;/../dist/config&lt;/outputDirectory&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;!--移动并重命名jar包--&gt;&lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;target&gt; &lt;move file="$&#123;project.basedir&#125;/target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.$&#123;project.packaging&#125;" tofile="$&#123;project.basedir&#125;/../dist/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.$&#123;project.packaging&#125;" /&gt; &lt;/target&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; &emsp;&emsp;进入到server/pom.xml同级目录，执行mvn clean package指令，打包成功会在dist目录下生成编译后的jar文件，dist/config目录下生成项目的配置文件 前端工程&emsp;&emsp;前端工程主要基于vue-cli脚手架创建，vue项目的环境搭建可以参照vue-用Vue-cli从零开始搭建一个Vue项目&emsp;&emsp;现在创建一个基础的vue项目，修改config/index.js配置以实现打包的静态资源生成至dist/html目录 &emsp;&emsp;进入到front/package.json同级目录，执行npm run build指令，打包成功会在dist/html目录生成静态文件 集成测试来个接口&emsp;&emsp;编写一个获取用户信息的接口@SpringBootApplication@Controllerpublic class ServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServerApplication.class, args); &#125; /** * 获取当前登录用户的个人信息 * * @return 当前登录用户的个人信息 */ @RequestMapping("/user/me") @ResponseBody public Map&lt;String, Object&gt; me() &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put("username", "admin"); result.put("roles", Arrays.asList("admin", "normal", "none")); result.put("depts", Arrays.asList("办公室", "组织部")); result.put("menus", Arrays.asList("工作台", "系统管理")); return result; &#125;&#125; 配置代理&emsp;&emsp;配置以下前端工程的代理转发，用于解决开发环境接口调试的跨域问题 写个页面&emsp;&emsp;写个前端页面测试后端接口，进入front/package.json同级目录执行npm i axios -s，修改HelloWord.vue组件为如下代码 &lt;template&gt; &lt;div class="hello"&gt; &lt;h1 v-if="loading"&gt;&#123;&#123; '正在加载用户信息' &#125;&#125;&lt;/h1&gt; &lt;h1 v-else-if="errMsg"&gt;&#123;&#123; errMsg &#125;&#125;&lt;/h1&gt; &lt;div v-else&gt; &lt;p&gt;username: &#123;&#123;userInfo.username&#125;&#125;&lt;/p&gt; &lt;p&gt;roles: &#123;&#123;userInfo.roles&#125;&#125;&lt;/p&gt; &lt;p&gt;depts: &#123;&#123;userInfo.depts&#125;&#125;&lt;/p&gt; &lt;p&gt;menus: &#123;&#123;userInfo.menus&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios'export default &#123; name: 'HelloWorld', data () &#123; return &#123; loading: false, userInfo: &#123; username: '', roles: [], depts: [], menus: [] &#125;, errMsg: null &#125; &#125;, created () &#123; this.loading = true axios.get('/api/user/me').then(response =&gt; &#123; this.userInfo = response.data &#125;).catch(err =&gt; &#123; console.error(err) this.errMsg = err &#125;).finally(() =&gt; &#123; this.loading = false &#125;) &#125;&#125;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1,h2 &#123; font-weight: normal;&#125;&lt;/style&gt; 进入测试链接http://localost:8081 单点部署nginx配置&emsp;&emsp;分离部署主要依赖于nginx来完成，利用nginx来分发前后端的内容，nginx的配置如下#user root;# linux下必须有此配置 不然会导致403权限不足worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log logs/access.log main; error_log logs/error.log error; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; set $application_path C:/workspace/java/server-front-separate;# 这里的父级路径需要根据项目路径设置 location /api &#123; proxy_pass http://localhost:8080/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location / &#123; alias $application_path/dist/html/; try_files $uri $uri/ /index.html last;# 解决页面刷新404问题 index index.html index.htm; &#125; &#125;&#125; 打包前后端应用 前端应用: 进入front/package.json同级目录，执行npm run build指令 后端应用: 进入server/pom.xml同级目录，执行mvn clean package指令 编写快速启动脚本（支持多环境） linux下启动脚本start.sh #!/bin/sh# 常量定义export BIN_PATH=$(cd `dirname $0`;pwd)echo BIN_PATH:[$BIN_PATH]cd $BIN_PATHcd ..export CONTEXT_PATH=`pwd`echo CONTEXT_PATH:[$CONTEXT_PATH]export LOG_PATH=/data/logs/ssoecho LOG_PATH:[$LOG_PATH]# 需要指定启动的模式是test，还是prod，默认是test，如果不指定的话ACTION_MODE=$1if [ "$ACTION_MODE" = "" ]then ACTION_MODE=testfiecho STARTING APPLICATION ACTION_MODE:[$ACTION_MODE]# 判断log文件夹是否存在 不存在则创建if [ ! -d $LOG_PATH ]; then mkdir $LOG_PATHfi# 删除历史的server.log文件rm -f $LOG_PATH/server.log# 后台启动应用 并输出控制台日志nohup java -jar server-0.0.1-SNAPSHOT.jar --spring.profiles.active=$ACTION_MODE &gt;&gt; $LOG_PATH/server.log 2&gt;&amp;1 &amp;# 显示输出前二十行的日志head -n 20 $LOG_PATH/server.log windows下启动脚本start.bat @echo off:: 设置jar名称set JAR_NAME=server-0.0.1-SNAPSHOT:: 常量定义set BIN_PATH=%~dp0echo BIN_PATH:[%BIN_PATH%]cd %BIN_PATH%cd ..set CONTEXT_PATH=%cd%echo CONTEXT_PATH:[%CONTEXT_PATH%]echo JAR_NAME:[%JAR_NAME%]:: 需要指定启动的模式是test，还是prod，默认是test，如果不指定的话set /p ACTION_MODE_INPUT=请输入启动环境，不输入采用默认环境[test]:if not "%ACTION_MODE_INPUT%" equ "" (set ACTION_MODE=%ACTION_MODE_INPUT%) else (set ACTION_MODE=test)echo STARTING APPLICATION ACTION_MODE:%ACTION_MODE%set PROCESS_NAME=JAVA_APP_%JAR_NAME%_%ACTION_MODE%title %PROCESS_NAME%echo PROCESS_NAME:[%PROCESS_NAME%]:: 后台启动应用 并输出控制台日志java -jar %JAR_NAME%.jar --spring.profiles.active=%ACTION_MODE% linux下关闭脚本stop.sh #!/bin/sh# 需要指定停止的模式是test，还是prod，默认是test，如果不指定的话默认取testACTION_MODE=$1if [ "$ACTION_MODE" = "" ]then ACTION_MODE=testfiecho STOPPING APPLICATION ACTION_MODE:[$ACTION_MODE]pid=`ps -ef | grep server-0.0.1-SNAPSHOT.jar | grep $ACTION_MODE | grep -v grep | awk '&#123;print $2&#125;'`# 判断进程是否再运行 在运行则终止if [ -n "$pid" ]then kill -9 $pid echo application stop successelse echo application already stopfi windows下关闭脚本stop.bat @echo off:: 设置jar名称set JAR_NAME=server-0.0.1-SNAPSHOT:: 需要指定终止的模式是test，还是prod，默认是test，如果不指定的话set /p ACTION_MODE_INPUT=请输入关闭应用的运行环境，不输入采用默认环境[test]:if not "%ACTION_MODE_INPUT%" equ "" (set ACTION_MODE=%ACTION_MODE_INPUT%) else (set ACTION_MODE=test)echo STARTING APPLICATION ACTION_MODE:%ACTION_MODE%echo JAR_NAME:[%JAR_NAME%]set PROCESS_NAME=JAVA_APP_%JAR_NAME%_%ACTION_MODE%echo PROCESS_NAME:[%PROCESS_NAME%]:: 杀死对应进程 tasklist /nh /fi "WINDOWTITLE eq %PROCESS_NAME%"|find /i "cmd.exe" &gt;nulif ERRORLEVEL 1 (echo Application already stop) else (taskkill /fi "WINDOWTITLE eq %PROCESS_NAME%" &gt;nul &amp; echo Application stop success)echo This window will close in 10 secondsping 127.1 -n 11 &gt;nul 启动nginx以及后端服务 windwos 运行nginx.exe 运行dist/bin/start.bat linux nginx -s start dist/bin/start.sh prod 源码获取https://github.com/calebman/server-front-separate]]></content>
      <categories>
        <category>前后端分离</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>vuejs</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2019-02-21-hello-hexo%2F</url>
    <content type="text"><![CDATA[从掘金切换到Hexo，多读多看多积累，崭新的开始 随手记一下Markdown的相关语法 希望以后能够养成随手记的习惯 毕竟 好记性 不如 烂笔头 标题# 内容 （一级标题） ## 内容 （二级标题） ### 内容 （三级标题） #### 内容 （四级标题） ##### 内容 （五级标题） ###### 内容 （六级标题） 效果如下 内容 （一级标题）内容 （二级标题）内容 （三级标题）内容 （四级标题）内容 （五级标题）内容 （六级标题）列表+ 奈文摩尔+ 上古巨神* 恐怖利刃* 混沌骑士- 炼金术士- 痛苦女王 1. 代达罗斯之殇2. 阿托斯之棍3. 梅肯斯姆* Steam * Dota2 * 绝地求生 * 中国式家长 效果如下 奈文摩尔 上古巨神 恐怖利刃 混沌骑士 炼金术士 痛苦女王 代达罗斯之殇 阿托斯之棍 梅肯斯姆 Steam Dota2 绝地求生 中国式家长 字体**加粗的文字***倾斜的文字*`***斜体加粗的文字***~~加删除线的文字~~ 效果如下 加粗的文字倾斜的文字`斜体加粗的文字加删除线的文字 引用&gt;引用内容&gt;&gt;效果如下&gt;&gt;&gt;&gt;&gt;&gt;可叠加的引用 效果如下 引用内容 效果如下 可叠加的引用 链接[github](https://github.com/calebman)[掘金](https://juejin.im/user/59bc7c00f265da0644289a4b) 效果如下 github掘金 分割线-------******** 效果如下 图片![图片介绍](http://chenjianhui.name/images/avatar.png) 效果如下 表格英雄|属性|大招--|:--:|--:奈文摩尔|敏捷|魂之挽歌受折磨的灵魂|智力|煤气罐混沌骑士|力量|混沌镜像 效果如下 英雄 属性 大招 奈文摩尔 敏捷 魂之挽歌 受折磨的灵魂 智力 煤气罐 混沌骑士 力量 混沌镜像 代码块(```) public static void main(String args[]) &#123; System.out.println(&quot;Hello World&quot;); &#125;(```) 效果如下 public static void main(String args[]) &#123; System.out.println("Hello World");&#125;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Netty构建Http容器]]></title>
    <url>%2F2018-05-23-build-http-server-with-netty%2F</url>
    <content type="text"><![CDATA[要实现怎样的效果 一个SpringBoot框架搭建起来的项目发布接口服务是这样的 SpringBoot搭建教程点击这里 @Controller@RequestMapping("/v1/product")public class DocController &#123; @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) @ResponseBody public WebResult search(@PathVariable("id") Integer id) &#123; logger.debug("获取指定产品接收产品id=&gt;%d", id); if (id == null || "".equals(id)) &#123; logger.debug("产品id不能为空"); return WebResult.error(ERRORDetail.RC_0101001); &#125; return WebResult.success(products.get(id)); &#125;&#125; 我希望我使用Netty构建的Web服务器也能使用这样便捷的注解方式去发布我的接口服务 该怎么做 使用Netty自带的编解码、聚合器构建一个带有Http编解码功能的服务器这一点其实非常简单，Netty提供了对应的Http协议的编解码以及聚合器，我们只需要在管道初始化的时候加载它们。 public class HttpPipelineInitializer extends ChannelInitializer&lt;Channel&gt; &#123; //编解码处理器名称 public final static String CODEC = "codec"; //HTTP消息聚合处理器名称 public final static String AGGEGATOR = "aggegator"; //HTTP消息压缩处理器名称 public final static String COMPRESSOR = "compressor"; @Override protected void initChannel(Channel channel) throws Exception &#123; ChannelPipeline pipeline = channel.pipeline(); pipeline.addLast(CODEC, new HttpServerCodec()); pipeline.addLast(AGGEGATOR, new HttpObjectAggregator(512 * 1024)); pipeline.addLast(COMPRESSOR,new HttpContentCompressor()); pipeline.addLast(new AllocHandler()); &#125;&#125; 实现RequestMapping注解，用于标识处理器或者控制器对应匹配的接口地址。 @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface RequestMapping &#123; String[] value() default &#123;&#125;;&#125; 提供启动入口，程序启动时创建Spring容器，并基于Spring初始化必要组件 提供程序入口类 public class CettyBootstrap &#123; private static final Logger logger = LoggerFactory.getLogger(CettyBootstrap.class); private static final String DEFAULT_SPRING_XMLPATH = "classpath:applicantContext.xml"; private static final String DEFAULT_HTTP_SERVER_BEAN_NAME = "defaultHttpServer"; public static void create() &#123; create(DEFAULT_SPRING_XMLPATH); &#125; public static void create(String springXmlpath) &#123; if (StringUtils.isEmpty(springXmlpath)) &#123; springXmlpath = DEFAULT_SPRING_XMLPATH; &#125; logger.debug("spring框架配置文件地址为&#123;&#125;", springXmlpath); try &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(springXmlpath.split("[,\\s]+")); context.start(); logger.debug("spring框架启动成功"); try &#123; context.getBean(DEFAULT_HTTP_SERVER_BEAN_NAME, DefaultHttpServer.class); &#125; catch (NoSuchBeanDefinitionException ex) &#123; logger.warn("未配置HttpServer，采用默认配置启动"); context.getAutowireCapableBeanFactory().createBean(DefaultHttpServer.class); &#125; &#125; catch (BeansException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 定义默认实现的HttpServer组件，随Spring容器启动时加载基于Netty的Web容器，并使用HandlerMapping组件初始化HttpPipelineInitializer管道，其中HandlerMapping如果未有用户定义则使用默认的DefaultHandlerMapping实现 public class DefaultHttpServer extends ApplicationObjectSupport &#123; private static final Logger logger = LoggerFactory.getLogger(DefaultHttpServer.class); private static final String DEFAULT_HTTP_PORT = "8080"; private static final String HANDLER_MAPPING_BEAN_NAME = "handlerMapping"; private String port; private HandlerMapping handlerMapping; public void setPort(String port) &#123; this.port = port; &#125; @Override public void initApplicationContext(ApplicationContext applicationContext) &#123; beforeInit(applicationContext); initHandlerMapping(applicationContext); initServer(); &#125; void initHandlerMapping(ApplicationContext context) &#123; try &#123; this.handlerMapping = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); &#125; catch (NoSuchBeanDefinitionException ex) &#123; this.handlerMapping = context.getAutowireCapableBeanFactory().createBean(DefaultHandlerMapping.class); &#125; &#125; void initServer() &#123; logger.debug("初始化服务器"); if (!HttpUtils.isPort(port)) &#123; logger.warn("端口号不合法，使用默认端口&#123;&#125;", DEFAULT_HTTP_PORT); port = DEFAULT_HTTP_PORT; &#125; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(Integer.parseInt(port))) .childHandler(new HttpPipelineInitializer(handlerMapping)); ChannelFuture f = b.bind().sync(); logger.info("服务启动成功，监听&#123;&#125;端口", port); f.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; workerGroup.shutdownGracefully().sync(); bossGroup.shutdownGracefully().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; protected void beforeInit(ApplicationContext applicationContext) &#123; &#125;&#125; 提供默认的HandlerMapping实现类，负责匹配@RequestMapping注解下的处理函数 public class DefaultHandlerMapping extends ApplicationObjectSupport implements HandlerMapping &#123; Logger logger = LoggerFactory.getLogger(DefaultHandlerMapping.class); private static Map&lt;String, HttpHandler&gt; httpHandlerMap = new HashMap&lt;String, HttpHandler&gt;(); @Override public void initApplicationContext(ApplicationContext context) throws BeansException &#123; logger.debug("初始化处理匹配器"); Map&lt;String, Object&gt; handles = context.getBeansWithAnnotation(Controller.class); try &#123; for (Map.Entry&lt;String, Object&gt; entry : handles.entrySet()) &#123; logger.debug("加载控制器&#123;&#125;", entry.getKey()); loadHttpHandler(entry.getValue()); &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; void loadHttpHandler(Object value) throws IllegalAccessException, InstantiationException &#123; Class clazz = value.getClass(); Object clazzFromInstance = clazz.newInstance(); Method[] method = clazz.getDeclaredMethods(); for (Method m : method) &#123; if (m.isAnnotationPresent(RequestMapping.class)) &#123; RequestMapping requestMapping = m.getAnnotation(RequestMapping.class); for (String url : requestMapping.value()) &#123; HttpHandler httpHandler = httpHandlerMap.get(url); if (httpHandler == null) &#123; logger.info("加载url为&#123;&#125;的处理器&#123;&#125;", url, m.getName()); httpHandlerMap.put(url, new HttpHandler(clazzFromInstance, m)); &#125; else &#123; logger.warn("url&#123;&#125;存在相同的处理器", url); &#125; &#125; &#125; &#125; &#125; @Override public HttpHandler getHadnler(FullHttpRequest request) &#123; return httpHandlerMap.get(request.uri()); &#125;&#125; 当请求进入时通过HandlerMapping组件匹配处理器，如果匹配失败则返回404 public class AllocHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123; private HandlerMapping handlerMapping; public AllocHandler(HandlerMapping handlerMapping) &#123; this.handlerMapping = handlerMapping; &#125; /* 异常处理 */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; sendError(ctx, HttpResponseStatus.INTERNAL_SERVER_ERROR); super.exceptionCaught(ctx, cause); &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest fullHttpRequest) throws Exception &#123; HttpHandler httpHandler = handlerMapping.getHadnler(fullHttpRequest); if (httpHandler != null) &#123; Object obj = httpHandler.execute(fullHttpRequest); if (obj instanceof String) &#123; sendMessage(ctx, obj.toString()); &#125; else &#123; sendMessage(ctx, JSONObject.toJSONString(obj)); &#125; &#125; else &#123; sendError(ctx, HttpResponseStatus.NOT_FOUND); &#125; &#125; private void sendMessage(ChannelHandlerContext ctx, String msg) &#123; FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8)); response.headers().set("Content-Type", "text/plain"); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); &#125; private void sendError(ChannelHandlerContext ctx, HttpResponseStatus httpResponseStatus) &#123; FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, httpResponseStatus, Unpooled.copiedBuffer(httpResponseStatus.toString(), CharsetUtil.UTF_8)); response.headers().set("Content-Type", "text/plain"); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); &#125;&#125; 测试与使用 建立一个TestController @Controllerpublic class TestController &#123; @RequestMapping("/test") public String testHandler(FullHttpRequest fullHttpRequest) &#123; return "1234"; &#125; @RequestMapping("/zx") public String zx(FullHttpRequest fullHttpRequest) &#123; return "zhuxiong"; &#125; @RequestMapping("/obj") public Object obj(FullHttpRequest fullHttpRequest) &#123; System.out.println("\n\n----------"); HttpHeaders httpHeaders = fullHttpRequest.headers(); Set&lt;String&gt; names = httpHeaders.names(); for (String name : names) &#123; System.out.println(name + " : " + httpHeaders.get(name)); &#125; System.out.println(""); ByteBuf byteBuf = fullHttpRequest.content(); byte[] byteArray = new byte[byteBuf.capacity()]; byteBuf.readBytes(byteArray); System.out.println(new String(byteArray)); System.out.println("----------\n\n"); JSONObject json = new JSONObject(); json.put("errCode", "00"); json.put("errMsg", "0000000(成功)"); json.put("data", null); return json; &#125;&#125; 启动Spring容器 public class HttpServerTest &#123; public static void main(String[] args) throws Exception &#123; CettyBootstrap.create(); // CettyBootstrap.create("classpath:applicationContext.xml"); &#125;&#125; 未来要做的 与Spring框架集成，将核心组件托管给Spring容器统一管理 提供静态资源映射 修改映射策略将请求映射至一个流程（一个处理器多个拦截器） 支持使用模板语法进行视图解析]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯正后端的vue轮子笔记]]></title>
    <url>%2F2018-05-18-vue-notes%2F</url>
    <content type="text"><![CDATA[说明由于公司需要，我作为一个纯正的后端工程师，已经自学了半年多的vue了，愣是被逼成了一个小全栈，当然，小全栈这是往好听了说，事实上就是个前后端深度都不足的小菜鸡，在深知自己众多不足以及明白好记性不如烂笔头的道理下，多造轮子多做笔记总是不会错的：） 所以最近得空我把我刚学vuejs的时候写的烂工程重构了一下，重构的时候针对性的分模块做了一些笔记如下 路由 状态管理 权限管理 控件封装与使用 混入 数据模拟 打包优化与用户体验 如果不想拉这么长可以去 全球最大的同性交友网站 查看 进入烂笔头模式 路由 1. 路由加载// 直接加载页面import page from '@/views/page';// 懒加载页面() =&gt; import('@/views/page');// 指定打包名称的懒加载，可将多个页面打包成一个js进行加载() =&gt; import(/* webpackChunkName: "group-page" */'@/views/page1');() =&gt; import(/* webpackChunkName: "group-page" */'@/views/page2');() =&gt; import(/* webpackChunkName: "group-page" */'@/views/page3'); 2. 404路由// 加载一个404页面import page404 from '@/views/page404';// 将以下路由配置放置在路由表的最末端，当路径无法匹配前面的所有路由时将会跳转至page404组件页面&#123; path: '*', component: page404&#125; 3. 路由拦截// 路由跳转前的拦截器router.beforeEach((to, from, next) =&gt; &#123; &#125;);// 路由跳转后的拦截器router.afterEach(to =&gt; &#123;&#125;);// 路由跳转时出现错误时的拦截器router.onError((err) =&gt; &#123;&#125;); 4. 动态路由 动态路由一般配合页面级的权限控制使用 // 通过router.addRoutes方法动态添加可访问路由router.addRoutes(addRouters)// hack方法 确保addRoutes已完成next(&#123; ...to, replace: true &#125;) // set the replace: true so the navigation will not leave a history record 5. 路由加载时动画 路由加载时的loading动画一般配合路由懒加载使用 // 在状态管理中定义一个路由loading标志const app = &#123; state: &#123; routerLoading: false, //路由的loading过渡 &#125;, mutations: &#123; //修改路由loading状态 UPDATE_ROUTER_LOADING(state, status) &#123; state.routerLoading = status &#125; &#125;&#125;// 在路由拦截器中修改loading状态router.beforeEach((to, from, next) =&gt; &#123; store.commit('UPDATE_ROUTER_LOADING', true); // 展示路由加载时动画&#125;);router.afterEach(to =&gt; &#123; store.commit('UPDATE_ROUTER_LOADING', false);&#125;);router.onError(err =&gt; &#123; console.error(err); // for bug store.commit('UPDATE_ROUTER_LOADING', false);&#125;);// 在router-view定义loading动画// element-ui提供了v-loading指令可以直接使用&lt;router-view v-loading="$store.getters.routerLoading"&gt;&lt;/router-view&gt; 状态管理 1. 小知识 state中的数据修改需要通过mutation或action触发 mutation中的方法必须是同步函数 action可包含任意异步操作，可返回一个Promise mutation以及action可以重复，调用时将会依次调用，getter必须唯一 2. 多模块 业务比较复杂时可使用状态管理中的多模块，有以下注意事项 除state会根据组合时模块的别名来添加层级，其他的都是合并在根级下，所以在回调函数获取的getters、commit、dispatch都是全局作用的 mutation的回调参数只有state，state为当前模块的状态树，下同 action的回调参数为state、rootState、getters、commit、dispatch，如果需要在action中调用其他的action可使用dispatch直接调用 getter的回调参数为state、rootState、getters 模块间可以通过回调的rootState进行交互 出现重名的mutation、action将依次触发// 多模块的实现 app以及user为各个子模块export default new Vuex.Store(&#123; modules: &#123; app, user &#125;, getters&#125;) 3. 辅助函数 Vuex除了提供了Store对象以外还对外提供了一些辅助函数 mapState、mapGetters将store中的state、getters属性映射到vue组件局部的计算属性中 import &#123; mapState &#125; from 'vuex'computed: mapState([ // 映射 this.name 到 this.$store.state.name 'name'])import &#123; mapGetters &#125; from 'vuex'computed: &#123; // 映射 this.name 到 this.$store.getters.name ...mapGetters([ 'name' ])&#125; mapActions、mapMutations将store中的dispatch、commit方法映射到vue组件局部的方法中 import &#123; mapActions &#125; from 'vuex'methods: &#123; // 映射 this.LoginByUsername() 到 this.$store.dispatch('LoginByUsername') ...mapActions([ 'LoginByUsername' ]), // 映射 this.login() to this.$store.dispatch('LoginByUsername') ...mapActions(&#123; login: 'LoginByUsername'&#125;) &#125;import &#123; mapMutations &#125; from 'vuex'methods: &#123; // 映射 this.SET_NAME() 到 this.$store.commit('SET_NAME') ]) ...mapMutations([ 'SET_NAME' ]) , // 映射 this.setName() 到 this.$store.commit('SET_NAME') &#125;) ...mapMutations(&#123; setName: 'SET_NAME' ])&#125; 4. 数据持久化插件 刷新页面时希望状态不被丢失时可用此插件 // 摘抄于 https://github.com/robinvdvleuten/vuex-persistedstateimport createPersistedState from 'vuex-persistedstate'import * as Cookies from 'js-cookie'const store = new Store(&#123; // ... plugins: [ createPersistedState(&#123; storage: &#123; getItem: key =* Cookies.get(key), // Please see https://github.com/js-cookie/js-cookie#json, on how to handle JSON. setItem: (key, value) =* Cookies.set(key, value, &#123; expires: 3, secure: true &#125;), removeItem: key =* Cookies.remove(key) &#125; &#125;) ]&#125;) 5. 日志插件 开发环境中希望能够跟踪状态变化并输出时可用此插件 // createLogger是vuex中的内置插件import createLogger from 'vuex/dist/logger'let vuexPlugins = [];if(process.env.NODE_ENV !== 'production')&#123; // 开发环境加载该插件 vuexPlugins.push(createLogger); &#125;const store = new Store(&#123; // ... plugins: vuexPlugins&#125;) 权限管理 1. 需要实现的功能 根据用户登录后的权限表生成路由 页面级的权限控制 dom元素级的权限控制 登录状态失效的处理 2. 路由设计 首先我们需要设计路由对象需要有哪些必要参数信息 为了实现权限管理我们必须要有roles参数代表该路由必须拥有哪些权限才能访问 为了更好的展示路由在这里设计了title、icon两个参数用于侧边栏的菜单展示 而有些路由不需要在侧边栏展示，这里使用hidden参数来告诉程序哪些路由是不需要展示的 // 首先设计路由对象参数/*** hidden: true 如果hidden为true则在左侧菜单栏展示，默认为false* name:'router-name' 路由名称，路由唯一标识* meta : &#123; roles: ['admin','editor'] 权限列表，用于页面级的权限控制，默认不设置代表任何权限均可访问 title: 'title' 对应路由在左侧菜单栏的标题名称 icon: 'icon-class' 对应路由在左侧菜单栏的图标样式 &#125;**/ 接下来我们需要实现路由的动态加载 系统初始化时加载必要路由，之后根据登录用户的权限加载符合条件的路由 // 定义系统初始化时加载的必要路由信息export const constantRouterMap = [ &#123; path: '/login', name: 'login', meta: &#123; title: "系统登录", hidden: true &#125;, component: login &#125;, &#123; path: "/404", name: "page404", meta: &#123; title: "页面走丢了", hidden: true &#125;, component: page404 &#125;, &#123; path: "/401", name: "page401", meta: &#123; title: "权限不足", hidden: true &#125;, component: page401 &#125;]// 定义布局页面const layout = () =&gt; import(/* webpackChunkName: "group-index" */ '@/views/layout');// 定义异步加载的路由信息export const asyncRouterMap = [ &#123; path: '/', name: 'main', redirect: '/dashboard', hidden: true, component: layout, children: [ &#123; path: 'dashboard', name: 'dashboard', meta: &#123; title: "仪表盘" &#125;, component: () =&gt; import(/* webpackChunkName: "group-index" */'@/views/dashboard') &#125; ] &#125;, &#123; path: '/permission', name: 'permission', meta: &#123; title: "权限页", icon: "dbm d-icon-quanxian" &#125;, redirect: '/permission/adminpermission', component: layout, children: [ &#123; path: "adminpermission", name: "adminPermission", meta: &#123; title: "管理员权限页", roles: ["admin"] &#125;, component: () =&gt; import('@/views/permission/admin') &#125;, &#123; path: "watcherpermission", name: "watcherPermission", meta: &#123; title: "游客权限页", roles: ["admin", "watcher"] &#125;, component: () =&gt; import('@/views/permission/watcher') &#125;, &#123; path: "elementpermission", name: "elementPermission", meta: &#123; title: "元素级别权限" &#125;, component: () =&gt; import('@/views/permission/element') &#125; ] &#125;, &#123; path: '*', redirect: '/404', hidden: true &#125;] 3. 页面级的权限控制 使用路由拦截来实现页面级的权限控制 拦截路由跳转判断用户是否登录 从拉取的用户信息中提取权限表通过addRoutes方法动态加载异步路由表 每次路由跳转时判断用户是否拥有该路由的访问权限实现动态权限匹配 // 定义免登白名单const whiteList = ['/login', '/404', '/401'];// 拦截路由跳转router.beforeEach((to, from, next) =&gt; &#123; store.commit('UPDATE_ROUTER_LOADING', true); // 展示路由加载时动画 if (getToken()) &#123; // 存在token if (to.path === '/login') &#123; next(&#123; path: '/' &#125;) &#125; else &#123; if (store.getters.roles.length === 0) &#123; // 判断当前用户是否已拉取完用户信息 store.dispatch('GetUserInfo').then(data =&gt; &#123; // 拉取用户信息 const roles = data.roles // 权限表必须为数组,例如: ['admin','editer'] store.dispatch('GenerateRoutes', &#123; roles &#125;).then(() =&gt; &#123; // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record &#125;) &#125;).catch(err =&gt; &#123; // 拉取用户信息失败，提示登录状态失效 store.dispatch('FedLogOut').then(() =&gt; &#123; Message.error('登录状态失效, 请重新登录'); next(&#123; path: '/login' &#125;); &#125;) &#125;) &#125; else &#123; if (hasPermission(store.getters.roles, to.meta.roles)) &#123; // 动态权限匹配 next(); &#125; else &#123; next(&#123; path: '/401', replace: true, query: &#123; noGoBack: true &#125; &#125;); &#125; &#125; &#125; &#125; else &#123; // 没有token if (whiteList.indexOf(to.path) !== -1) &#123; // 在免登录白名单，直接进入 next(); &#125; else &#123; next('/login'); // 否则全部重定向到登录页 &#125; &#125;&#125;); 4. 元素级的权限控制 使用自定义指令来实现元素级的权限控制 在被绑定元素插入父节点时验证用户是否包含该元素的所需权限 根据鉴权结果来决定是否移除该元素 import store from '@/store'export default &#123; inserted(el, binding, vnode) &#123; const &#123; value &#125; = binding; // 获取自定义指令传入的鉴权信息 const roles = store.getters &amp;&amp; store.getters.roles; // 从状态管理中获取当前用户的路由信息 if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) &#123; const permissionRoles = value; const hasPermission = roles.some(role =&gt; &#123; // 判断用户是否包含该元素所需权限 return permissionRoles.includes(role); &#125;) if (!hasPermission) &#123; // 权限不足 el.parentNode &amp;&amp; el.parentNode.removeChild(el); // 移除该dom元素 &#125; &#125; else &#123; throw new Error(`必须要有权限写入，例如['admin']`) &#125; &#125;&#125;// 在vue组件上使用它// 引入并注册permission指令import permission from "@/directive/permission/index.js";export default &#123; directives: &#123; permission &#125;&#125;// 使用permission指令&lt;el-button v-permission="['admin']"&gt;admin 可见&lt;/el-button&gt;&lt;el-button v-permission="['admin','watcher']"&gt;watcher 可见&lt;/el-button&gt; render函数 1. 如何封装一个支持render渲染的组件 首先创建一个函数式组件 // 表格拓展函数式组件的实现// see https://github.com/calebman/vue-DBM/blob/master/src/components/table/expand.jsexport default &#123; name: 'TableExpand', functional: true, // 标记组件为 functional，这意味它是无状态 (没有响应式数据)，无实例 (没有 this 上下文)。 props: &#123; row: Object, // 当前行对象 field: String, // 列名称 index: Number, // 行号 render: Function // 渲染函数 &#125;, render: (h, ctx) =&gt; &#123; // 提供ctx作为上下文 const params = &#123; row: ctx.props.row, field: ctx.props.field, index: ctx.props.index &#125;; return ctx.props.render(h, params); &#125;&#125;; 在父组件中引入 // see https://github.com/calebman/vue-DBM/blob/master/src/components/table/table.vueimport expand from "./expand.js";&lt;span v-if="typeof col.render ==='function'"&gt; &lt;expand :field="col.field" :row="item" :render="col.render" :index="rowIndex"&gt;&lt;/expand&gt;&lt;/span&gt; 使用render函数渲染 // see https://github.com/calebman/vue-DBM/blob/master/src/views/demo/datatable/data-table.vue// 引入自定义组件import IndexColumn from "@/components/business/index-column.vue";// 注册components: &#123; // ... IndexColumn&#125;// 使用// 获取当前组件的上下文let self = this;// 定义渲染函数render: (h, params) =&gt; h("div", [ h(IndexColumn, &#123; props: &#123; field: params.field, index: params.index, pagingIndex: (self.pagination.pageCurrent - 1) * self.pagination.pageSize &#125;, on: &#123; "on-value-delete": self.deleteRow &#125; &#125;) ]) 混入 1. 小知识 混入对象将享有被混入组件的生命周期 数据对象混入冲突时将以组件数据优先 对象选项（如methods、components、directives）混入冲突时取组件对象的键值对 同名钩子混合为数组，混入对象的钩子将在组件自身钩子之前调用 2. 应用场景 希望部分路由页面在离开时销毁但是不希望每个路由页面都定义局部路由时 // 定义混入对象export default &#123; beforeRouteLeave(to, from, next) &#123; if (to.meta &amp;&amp; to.meta.destroy) &#123; this.$destroy(); &#125; next(); &#125;&#125;// 混入需要此功能的组件页面import routeLeaveDestoryMixin from "routeleave-destory-mixin";export default &#123; // ... mixins: [routeLeaveDestoryMixin]&#125; 数据表格自定义了文本、数字、时间以及文件单元格组件，每个组件都有同样的数据修改、焦点选中等方法时，可提取为混入对象，提高组件复用性 // see https://github.com/calebman/vue-DBM/blob/master/src/components/business/render-column-mixin.js// 定义混入对象export default &#123; // ... computed: &#123; // 是否选中此单元格 inSelect() &#123; if (this.cellClickData.index == this.index &amp;&amp; this.cellClickData.field == this.field) &#123; this.focus(); return true; &#125; &#125; &#125;, methods: &#123; // 获取焦点 focus() &#123; let self = this; setTimeout(function () &#123; if (self.$refs["rendercolumn"]) &#123; self.$refs["rendercolumn"].focus(); &#125; &#125;, 100); &#125;, // 失去焦点 blur() &#123; if (this.v != this.value) &#123; this.$emit("on-value-change", this.field, this.index, this.v); &#125; this.$emit("on-value-cancel", this.field, this.index); &#125;, // 数据修改 changeValue(val) &#123; this.$emit("on-value-change", this.field, this.index, val); this.$emit("on-value-cancel", this.field, this.index); &#125; &#125;, watch: &#123; // 监听父组件数据变化 value(val) &#123; this.v = val; &#125; &#125;&#125;// 文本列// see https://github.com/calebman/vue-DBM/blob/master/src/components/business/text-column.vue&lt;template&gt; &lt;div&gt; &lt;input v-show="inSelect" ref="rendercolumn" @blur="blur" @keyup="enter($event)" v-model="v" /&gt; &lt;span v-show="!inSelect" class="cell-text"&gt;&#123;&#123;v&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;// 时间列// see https://github.com/calebman/vue-DBM/blob/master/src/components/business/datetime-column.vue&lt;template&gt; &lt;div&gt; &lt;el-date-picker v-show="inSelect" ref="rendercolumn" v-model="v" type="datetime" @change="changeValue" @blur="blur"&gt;&lt;/el-date-picker&gt; &lt;span v-show="!inSelect"&gt;&#123;&#123;coverValue&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 希望降低组件的复杂度的时候可使用多个混入组件来分割核心组件的功能 # see https://github.com/calebman/vue-DBM/tree/master/src/components/table├─table│ cell-edit-mixin.js # 单元格编辑│ classes-mixin.js # 表格样式 │ scroll-bar-control-mixin.js # 表格滚动│ table-empty-mixin.js # 无数据时的处理│ table-resize-mixin.js # 表格的自适应│ table-row-mouse-events-mixin.js # 鼠标移动时的样式改变 数据模拟 1. 需要实现的功能 拦截Ajax请求并延时响应 返回的统一的数据格式 响应不同的模拟数据 2. 配置Mockjs拦截Ajax请求// see https://github.com/calebman/vue-DBM/blob/master/src/mock/index.js// 引入Mockjsimport Mock from 'mockjs';// 配置延时Mock.setup(&#123; timeout: '300-1000'&#125;);// 配置拦截Mock.mock(/\/user\/login/, 'post', loginAPI.loginByUsername);Mock.mock(/\/user\/logout/, 'post', loginAPI.logout);Mock.mock(/\/user\/info\.*/, 'get', loginAPI.getUserInfo); 3. 响应的统一数据格式// see https://github.com/calebman/vue-DBM/blob/master/src/mock/response.js/** * 统一响应工具类 * 响应统一格式的数据 * response : &#123; * errCode: 00 响应结果码 * errMsg: 0000000（成功） 响应详细结果码 * data: null 具体数据 * &#125; */ export default &#123; // 成功 success: data =&gt; &#123; return &#123; errCode: '00', errMsg: '0000000（成功）', data: data ? data : null &#125; &#125;, // 失败 fail: (errCode, errMsg) =&gt; &#123; return &#123; errCode: errCode ? errCode : '04', errMsg: errMsg ? errMsg : '0401001（未知错误）', data: null &#125; &#125;, // 权限不足 unauthorized: () =&gt; &#123; return &#123; errCode: '43', errMsg: '4300001（无权访问）', data: null &#125; &#125;&#125; 4. 配置响应逻辑// see https://github.com/calebman/vue-DBM/blob/master/src/mock/login.jsimport &#123; param2Obj &#125; from '@/utils';import Response from './response';const userMap = &#123; admin: &#123; password: 'admin', roles: ['admin'], token: 'admin', introduction: '我是超级管理员', avatar: 'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif', name: 'Super Admin' &#125;, watcher: &#123; password: 'watcher', roles: ['watcher'], token: 'watcher', introduction: '我是游客', avatar: 'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif', name: 'Normal Watcher' &#125;&#125;export default &#123; // 使用用户名登录 loginByUsername: config =&gt; &#123; const &#123; username, password &#125; = JSON.parse(config.body); if (userMap[username] &amp;&amp; userMap[username].password === password) &#123; return Response.success(userMap[username]); &#125; else &#123; return Response.fail("01", "0101001（用户名或密码错误）") &#125; &#125;, // 拉取用户信息 getUserInfo: config =&gt; &#123; const &#123; token &#125; = param2Obj(config.url); if (userMap[token]) &#123; return Response.success(userMap[token]); &#125; else &#123; return Response.fail(); &#125; &#125;, // 注销 logout: () =&gt; Response.success()&#125; 5. 模拟随机数据// see https://github.com/nuysoft/Mock/wikiimport Mock from 'mockjs';// 随机字符串function mockStr() &#123; let result = Mock.mock(&#123; 'str': '@name' &#125;); return result.str;&#125;// 随机数字function mockNumber(min, max) &#123; let key = 'num|' + min + '-' + max; let param = &#123;&#125; param[key] = 100; return Mock.mock(param).num;&#125;// 随机小数，最高小数点后三位function mockDecimal() &#123; return Mock.Random.float(1, 100, 1, 3)&#125;// 随机数组一项const arr = ["image2.jpeg", "image3.jpeg", "image4.jpeg", "image5.jpeg", "image6.jpeg"];function mockOneFileAddress() &#123; return Mock.mock(&#123; 'oneFile|1': arr &#125;).oneFile;&#125;// 随机日期function mockDate() &#123; let mockDateStr = Mock.Random.datetime('yyyy-MM-dd HH:mm:ss'); // 在这里使用了momentjs将其解析为Date类型 let mockDate = moment(mockDateStr, 'YYYY-MM-DD HH:mm:ss').toDate(); return mockDate;&#125; 打包优化 1. 做哪部分的优化 cdn优化 路由懒加载 其他优化 用户体验 2. cdn优化 类似于vue、vue-router、moment、element-ui等提供了cdn的架或者工具类可在index.html中直接引入，然后配置webpack的externals使其不加入打包配置，从而减小app.js、vendor.js的体积 在index.html使用cdn引入依赖库 &lt;!-- 网络请求工具类 --&gt;&lt;script src="https://cdn.bootcss.com/axios/0.18.0/axios.min.js"&gt;&lt;/script&gt;&lt;!-- vue --&gt;&lt;script src="https://cdn.bootcss.com/vue/2.5.16/vue.min.js"&gt;&lt;/script&gt;&lt;!-- vue-router --&gt;&lt;script src="https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js"&gt;&lt;/script&gt;&lt;!-- vuex --&gt;&lt;script src="https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js"&gt;&lt;/script&gt;&lt;!-- momentjs的中文包 --&gt;&lt;script src="https://cdn.bootcss.com/moment.js/2.22.1/moment-with-locales.min.js"&gt;&lt;/script&gt;&lt;!-- momentjs --&gt;&lt;script src="https://cdn.bootcss.com/moment.js/2.22.1/locale/zh-cn.js"&gt;&lt;/script&gt;&lt;!-- element-ui样式 --&gt;&lt;script src="https://cdn.bootcss.com/element-ui/2.3.6/theme-default/index.css"&gt;&lt;/script&gt;&lt;!-- element-ui --&gt;&lt;script src="https://cdn.bootcss.com/element-ui/2.3.6/index.js"&gt;&lt;/script&gt; 配置build文件夹下webpack.base.conf.js文件 module.exports = &#123; // ... externals: &#123; 'axios': 'axios', 'vue': 'Vue', 'vue-router': 'VueRouter', 'vuex': 'Vuex', 'moment': 'moment', 'element-ui': 'ELEMENT' &#125;&#125; 3. 路由懒加载 路由懒加载能够将代码根据路由配置进行分割，加快首屏渲染的速度，在大型的单页应用中是必不可少的 参见路由管理的实现 5. 其他优化 尽量少的注册全局组件，使用UI框架可以参考文档做按需加载 可以和服务端配合采用gzip压缩，减少传输耗时 在更新不是很频繁的应用可考虑提高缓存时间 例如moment、lodash这种庞大的工具库在使用的功能不多的情况下可考虑寻找替代品 6. 用户体验 一个单页应用到了一定规模不管怎么优化首屏渲染还是一个比较慢的过程，此时可以考虑在首屏渲染时使用一个加载动画告诉用户系统正在初始化 首先在index.html中定义一个渲染动画 &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- 首屏渲染时的加载动画 --&gt; &lt;div id="system-loading" class="showbox"&gt; &lt;div class="loader"&gt; &lt;svg class="circular" viewBox="25 25 50 50"&gt; &lt;circle class="path" cx="50" cy="50" r="20" fill="none" stroke-width="2" stroke-miterlimit="10" /&gt; &lt;/svg&gt; &lt;/div&gt; &lt;div class="text"&gt; &lt;span&gt;系统初始化中...&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt; 然后在App.vue组件的mounted钩子中移除这个loading export default &#123; // ... mounted() &#123; document.body.removeChild(document.getElementById("system-loading")); &#125;&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>vue-router</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成环境搭建]]></title>
    <url>%2F2018-02-21-build-springboot-env%2F</url>
    <content type="text"><![CDATA[本文简介 为什么使用SpringBoot 搭建怎样一个环境 开发环境 导入快速启动项目 集成前准备 集成Mybatis 集成Swagger2 多环境配置 多环境下的日志配置 常用配置 为什么使用SpringBoot&emsp;&emsp; SpringBoot相对于传统的SSM框架的优点是提供了默认的样板化配置，简化了Spring应用的初始搭建过程，如果你不想被众多的xml配置文件困扰，可以考虑使用SpringBoot替代 搭建怎样一个环境&emsp;&emsp; 本文将基于Spring官方提供的快速启动项目模板集成Mybatis、Swagger2框架，并讲解mybatis generator一键生成代码插件、logback、一键生成文档以及多环境的配置方法，最后再介绍一下自定义配置的注解获取、全局异常处理等经常用到的东西。 开发环境&emsp;&emsp; 本人使用IDEA作为开发工具，IDEA下载时默认集成了SpringBoot的快速启动项目可以直接创建，如果使用Eclipse的同学可以考虑安装SpringBoot插件或者直接从这里配置并下载SpringBoot快速启动项目，需要注意的是本次环境搭建选择的是SpringBoot2.0的快速启动框架，SpringBoot2.0要求jdk版本必须要在1.8及以上。 导入快速启动项目&emsp;&emsp; 不管是由IDEA导入还是现实下载模板工程都需要初始化快速启动工程的配置，如果使用IDEA，在新建项目时选择Spring Initializr，主要配置如下图&emsp;&emsp; 点击next之后finish之后IDEA显示正在下载模板工程，下载完成后会根据pom.xml下载包依赖，依赖下载完毕后模板项目就算创建成功了，如果是直接从官方网站配置下载快速启动项目可参考下图配置&emsp;&emsp; 从Search for dependencies 框中输入并选择Web、Mysql、Mybatis加入依赖，点击Generate Project下载快速启动项目，然后在IDE中选择导入Maven项目，项目导入完成后可见其目录结构如下图&emsp;&emsp; 需要关注红色方框圈起来的部分，由上往下第一个java类是用来启动项目的入口函数，第二个properties后缀的文件是项目的配置文件，第三个是项目的依赖包以及执行插件的配置 集成前准备修改.properties为.yml&emsp;&emsp; yml相对于properties更加精简而且很多官方给出的Demo都是yml的配置形式，在这里我们采用yml的形式代替properties，相对于properties形式主要有以下两点不同 对于键的描述由原有的 “.” 分割变成了树的形状 对于所有的键的后面一个要跟一个空格，不然启动项目会报配置解析错误 # properties式语法描述spring.datasource.name = mysqlspring.datasource.url = jdbc:mysql://localhost:3306/db?characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = 123# yml式语法描述spring: datasource: name: mysql url: jdbc:mysql://localhost:3306/db?characterEncoding=utf-8 username: root password: 123 配置所需依赖&emsp;&emsp; 快速启动项目创建成功后我们观察其pom.xml文件中的依赖如下图，包含了我们选择的Web、Mybatis以及Mysql&lt;!-- spring web mvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &emsp;&emsp; 但是我们使用ORM框架一般还会配合数据库连接池以及分页插件来使用，在这里我选择了阿里的druid以及pagehelper这个分页插件，再加上我们还需要整合swagger2文档自动化构建框架，所以增加了以下四个依赖项&lt;!-- 分页插件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- alibaba的druid数据库连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- alibaba的json格式化对象 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 自动生成API文档 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/dependency&gt; 集成Mybatis&emsp;&emsp; Mybatis的配置主要包括了druid数据库连接池、pagehelper分页插件、mybatis-generator代码逆向生成插件以及mapper、pojo扫描配置 配置druid数据库连接池&emsp;&emsp; 添加以下配置至application.yml文件中spring: datasource: # 如果存在多个数据源，监控的时候可以通过名字来区分开来 name: mysql # 连接数据库的url url: jdbc:mysql://localhost:3306/db?characterEncoding=utf-8 # 连接数据库的账号 username: root # 连接数据库的密码 password: 123 # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource # 扩展插件 # 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall filters: stat # 最大连接池数量 maxActive: 20 # 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 initialSize: 1 # 获取连接时最大等待时间，单位毫秒 maxWait: 60000 # 最小连接池数量 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 # 连接保持空闲而不被驱逐的最长时间 minEvictableIdleTimeMillis: 300000 # 用来检测连接是否有效的sql，要求是一个查询语句 # 如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用 validationQuery: select count(1) from 'table' # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效 testWhileIdle: true # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnBorrow: false # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnReturn: false # 是否缓存preparedStatement，即PSCache poolPreparedStatements: false # 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true maxOpenPreparedStatements: -1 配置pagehelper分页插件# pagehelper分页插件pagehelper: # 数据库的方言 helperDialect: mysql # 启用合理化，如果pageNum &lt; 1会查询第一页，如果pageNum &gt; pages会查询最后一页 reasonable: true 代码逆向生成插件mybatis-generator的配置及运行&emsp;&emsp; mybatis-generator插件的使用主要分为以下三步 pom.xml中添加mybatis-generator插件 &lt;build&gt; &lt;plugins&gt; &lt;!-- 将Spring Boot应用打包为可执行的jar或war文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 扫描resources/generator目录下的generatorConfig.xml配置 --&gt; &lt;configurationFile&gt; $&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml &lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.创建逆向代码生成配置文件generatorConfig.xml &emsp;&emsp; 参照pom.xml插件配置中的扫描位置，在resources目录下创建generator文件夹，在新建的文件夹中创建generatorConfig.xml配置文件，文件的详细配置信息如下&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 运行方式:mvaen运行命令 mybatis-generator:generate -e --&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;properties resource="generator/generator.properties"/&gt; &lt;classPathEntry location="$&#123;classPathEntry&#125;"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/$&#123;db&#125;?characterEncoding=utf-8" userId="$&#123;userId&#125;" password="$&#123;password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="$&#123;pojoTargetPackage&#125;" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="$&#123;mapperTargetPackage&#125;" targetProject="src/main/resources"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;daoTargetPackage&#125;" targetProject="src/main/java"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 schema是数据库名称--&gt; &lt;table tableName="%" schema="$&#123;db&#125;"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; &emsp;&emsp; 为了将generatorConfig.xml配置模板化，在这里将变动性较大的配置项单独提取出来作为一个generatorConfig.xml的配置文件，然后通过properties标签读取此文件的配置，这样做的好处是当需要多处复用此xml时只需要关注少量的配置项。&emsp;&emsp; 在generatorConfig.xml同级创建generator.properties文件，现只需要配置generator.properties文件即可，配置内容如下# 请手动配置以下选项# 数据库驱动:选择你的本地硬盘上面的数据库驱动包classPathEntry = D:/CJH/maven-repository/mysql/mysql-connector-java/5.1.30/mysql-connector-java-5.1.30.jar# 数据库名称、用户名、密码db = dbuserId = rootpassword = 123# 生成pojo的包名位置 在src/main/java目录下pojoTargetPackage = com.spring.demo.springbootexample.mybatis.po# 生成DAO的包名位置 在src/main/java目录下daoTargetPackage = com.spring.demo.springbootexample.mybatis.mapper# 生成Mapper的包名位置 位于src/main/resources目录下mapperTargetPackage = mapper 运行mybatis-generator插件生成Dao、Model、Mapping # 打开命令行cd到项目pom.xml同级目录运行以下命令mvn mybatis-generator:generate -e mybatis扫描包配置&emsp;&emsp; 至此已经生成了指定数据库对应的实体、映射类，但是还不能直接使用，需要配置mybatis扫描地址后才能正常调用 在application.yml配置mapper.xml以及pojo的包地址 mybatis: # mapper.xml包地址 mapper-locations: classpath:mapper/*.xml # pojo生成包地址 type-aliases-package: com.spring.demo.springbootexample.mybatis.po 在SpringBootExampleApplication.java中开启Mapper扫描注解 @SpringBootApplication@MapperScan("com.spring.demo.springbootexample.mybatis.mapper")public class SpringBootExampleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootExampleApplication.class, args); &#125;&#125; 测试mapper的有效性@Controllerpublic class TestController &#123; //替换成自己生成的mapper @Autowired UserMapper userMapper; @RequestMapping("/test") @ResponseBody public Object test()&#123; //查询该表的所有数据 return userMapper.selectByExample(null); &#125;&#125; &emsp;&emsp; 启动SpringBootExampleApplication.java的main函数，如果没有在application.yml特意配置server.port那么springboot会采用默认的8080端口运行，运行成功将打印如下日志Tomcat started on port(s): 8080 (http) with context path '' 在浏览器输入地址如果返回表格的中的所有数据代表mybatis集成成功http://localhost:8080/test 集成Swagger2&emsp;&emsp; Swagger2是一个文档快速构建工具，能够通过注解自动生成一个Restful风格json形式的接口文档，并可以通过如swagger-ui等工具生成html网页形式的接口文档，swagger2的集成比较简单，使用需要稍微熟悉一下，集成、注解与使用分如下四步 建立SwaggerConfig文件 @Configurationpublic class SwaggerConfig &#123; // 接口版本号 private final String version = "1.0"; // 接口大标题 private final String title = "SpringBoot示例工程"; // 具体的描述 private final String description = "API文档自动生成示例"; // 服务说明url private final String termsOfServiceUrl = "http://www.kingeid.com"; // licence private final String license = "MIT"; // licnce url private final String licenseUrl = "https://mit-license.org/"; // 接口作者联系方式 private final Contact contact = new Contact("calebman", "https://github.com/calebman", "chenjianhui0428@gmail.com"); @Bean public Docket buildDocket() &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(buildApiInf()) .select().build(); &#125; private ApiInfo buildApiInf() &#123; return new ApiInfoBuilder().title(title).termsOfServiceUrl(termsOfServiceUrl).description(description) .version(version).license(license).licenseUrl(licenseUrl).contact(contact).build(); &#125;&#125; 在SpringBootExampleApplication.java中启用Swagger2注解 &emsp;&emsp; 在@SpringBootApplication注解下面加上@EnableSwagger2注解 常用注解示例 //Contorller中的注解示例@Controller@RequestMapping("/v1/product")// 表示标识这个类是swagger的资源 @Api(value = "DocController", tags = &#123;"restful api示例"&#125;)public class DocController extends BaseController &#123; @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.PUT) @ResponseBody //表示一个http请求的操作 @ApiOperation(value = "修改指定产品", httpMethod = "PUT", produces = "application/json") //@ApiImplicitParams用于方法，包含多个@ApiImplicitParam表示单独的请求参数 @ApiImplicitParams(&#123;@ApiImplicitParam(name = "id", value = "产品ID", required = true, paramType = "path")&#125;) public WebResult update(@PathVariable("id") Integer id, @ModelAttribute Product product) &#123; logger.debug("修改指定产品接收产品id与产品信息=&gt;%d,&#123;&#125;", id, product); if (id == null || "".equals(id)) &#123; logger.debug("产品id不能为空"); return WebResult.error(ERRORDetail.RC_0101001); &#125; return WebResult.success(); &#125;&#125;//Model中的注解示例//表示对类进行说明，用于参数用实体类接收 @ApiModel(value = "产品信息")public class Product &#123; //表示对model属性的说明或者数据操作更改 @ApiModelProperty(required = true, name = "name", value = "产品名称", dataType = "query") private String name; @ApiModelProperty(name = "type", value = "产品类型", dataType = "query") private String type;&#125; 生成json形式的文档 &emsp;&emsp; 集成成功后启动项目控制台会打印级别为INFO的日志，截取部分如下，表明可通过访问应用的v2/api-docs接口得到文档api的json格式数据，可在浏览器输入指定地址验证集成是否成功Mapped &quot;&#123;[/v2/api-docs],methods=[GET],produces=[application/json || application/hal+json]&#125;&quot; http://localhost:8080/v2/api-docs 多环境配置&emsp;&emsp; 应用研发过程中多环境是不可避免的，假设我们现在有开发、演示、生产三个不同的环境其配置也不同，如果每次都在打包环节来进行配置难免出错，SpringBoot支持通过命令启动不同的环境，但是配置文件需要满足application-{profile}.properties的格式，profile代表对应环境的标识，加载时可通过不同命令加载不同环境。application-dev.properties：开发环境application-test.properties：演示环境application-prod.properties：生产环境# 运行演示环境命令java -jar spring-boot-example-0.0.1-SNAPSHOT --spring.profiles.active=test &emsp;&emsp; 基于现在的项目实现多环境我们需要在application.yml同级目录新建application-dev.yml、application-test.yml、application-prod.yml三个不同环境的配置文件，将不变的公有配置如druid的大部分、pagehelper分页插件以及mybatis包扫描配置放置于application.yml中，并在application.yml中配置默认采用开发环境，那么如果不带–spring.profiles.active启动应用就默认为开发环境启动，变动较大的配置如数据库的账号密码分别写入不同环境的配置文件中spring: profiles: # 默认使用开发环境 active: dev &emsp;&emsp; 配置到这里我们的项目目录结构如下图所示 &emsp;&emsp; 至此我们分别完成了Mybatis、Swagger2以及多环境的集成，接下来我们配置多环境下的logger。对于logger我们总是希望在项目研发过程中越多越好，能够给予足够的信息定位bug，项目处于演示或者上线状态时为了不让日志打印影响程序性能我们只需要警告或者错误的日志，并且需要写入文件，那么接下来就基于logback实现多环境下的日志配置 多环境下的日志配置&emsp;&emsp; 创建logback-spring.xml在application.yml的同级目录，springboot推荐使用logback-spring.xml而不是logback.xml文件，logback-spring.xml的配置内容如下所示&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 简要描述 日志格式 =&gt; %d&#123;HH:mm:ss.SSS&#125;(时间) [%-5level](日志级别) %logger&#123;36&#125;(logger名字最长36个字符，否则按照句点分割) - %msg%n(具体日志信息并且换行) 开发环境 =&gt; $&#123;basepackage&#125;包下控制台打印DEBUG级别及以上、其他包控制台打印INFO级别及以上 演示（测试）环境 =&gt; $&#123;basepackage&#125;包下控制台打印INFO级别及以上、其他包控制台以及文件打印WARN级别及以上 生产环境 =&gt; 控制台以及文件打印ERROR级别及以上 日志文件生成规则如下： 文件生成目录 =&gt; $&#123;logdir&#125; 当日的log文件名称 =&gt; $&#123;appname&#125;.log 其他时候的log文件名称 =&gt; $&#123;appname&#125;.%d&#123;yyyy-MM-dd&#125;.log 日志文件最大 =&gt; $&#123;maxsize&#125; 最多保留 =&gt; $&#123;maxdays&#125;天 --&gt; &lt;!--自定义参数 --&gt; &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt; &lt;property name="maxsize" value="30MB" /&gt; &lt;!--只保留最近90天的日志--&gt; &lt;property name="maxdays" value="90" /&gt; &lt;!--application.yml 传递参数 --&gt; &lt;!--log文件生成目录--&gt; &lt;springProperty scope="context" name="logdir" source="resources.logdir"/&gt; &lt;!--应用名称--&gt; &lt;springProperty scope="context" name="appname" source="resources.appname"/&gt; &lt;!--项目基础包--&gt; &lt;springProperty scope="context" name="basepackage" source="resources.basepackage"/&gt; &lt;!--输出到控制台 ConsoleAppender--&gt; &lt;appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!--展示格式 layout--&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%-5level] %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--输出到文件 FileAppender--&gt; &lt;appender name="fileLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则 如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天 的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。 --&gt; &lt;File&gt;$&#123;logdir&#125;/$&#123;appname&#125;.log&lt;/File&gt; &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt; &lt;FileNamePattern&gt;$&#123;logdir&#125;/$&#123;appname&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;maxHistory&gt;$&#123;maxdays&#125;&lt;/maxHistory&gt; &lt;totalSizeCap&gt;$&#123;maxsize&#125;&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;!--日志输出编码格式化--&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%-5level] %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 开发环境--&gt; &lt;springProfile name="dev"&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="consoleLog"/&gt; &lt;/root&gt; &lt;!-- additivity是子Logger 是否继承 父Logger 的 输出源（appender） 的标志位 在这里additivity配置为false代表如果$&#123;basepackage&#125;中有INFO级别日志则子looger打印 root不打印 --&gt; &lt;logger name="$&#123;basepackage&#125;" level="DEBUG" additivity="false"&gt; &lt;appender-ref ref="consoleLog"/&gt; &lt;/logger&gt; &lt;/springProfile&gt; &lt;!-- 演示（测试）环境--&gt; &lt;springProfile name="test"&gt; &lt;root level="WARN"&gt; &lt;appender-ref ref="consoleLog"/&gt; &lt;appender-ref ref="fileLog"/&gt; &lt;/root&gt; &lt;logger name="$&#123;basepackage&#125;" level="INFO" additivity="false"&gt; &lt;appender-ref ref="consoleLog"/&gt; &lt;appender-ref ref="fileLog"/&gt; &lt;/logger&gt; &lt;/springProfile&gt; &lt;!-- 生产环境 --&gt; &lt;springProfile name="prod"&gt; &lt;root level="ERROR"&gt; &lt;appender-ref ref="consoleLog"/&gt; &lt;appender-ref ref="fileLog"/&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; &emsp;&emsp; 日志配置中引用了application.yml的配置信息，主要有logdir、appname、basepackage三项，logdir是日志文件的写入地址，可以传入相对路径，appname是应用名称，引入这项是为了通过日志文件名称区分是哪个应该输出的，basepackage是包过滤配置，比如开发环境中需要打印debug级别以上的日志，但是又想使除我写的logger之外的DEBUG不打印，可过滤到本项目的包名才用DEBUG打印，此外包名使用INFO级别打印，在application.yml中新建这三项配置，也可在不同环境配置不同属性#应用配置resources: # log文件写入地址 logdir: logs/ # 应用名称 appname: spring-boot-example # 日志打印的基础扫描包 basepackage: com.spring.demo.springbootexample &emsp;&emsp; 使用不同环境启动测试logger配置是否生效，在开发环境下将打印DEBUG级别以上的四条logger记录，在演示环境下降打印INFO级别以上的三条记录并写入文件，在生产环境下只打印ERROR级别以上的一条记录并写入文件@RequestMapping("/logger")@ResponseBodypublic WebResult logger() &#123; logger.trace("日志输出 &#123;&#125;", "trace"); logger.debug("日志输出 &#123;&#125;", "debug"); logger.info("日志输出 &#123;&#125;", "info"); logger.warn("日志输出 &#123;&#125;", "warn"); logger.error("日志输出 &#123;&#125;", "error"); return "00";&#125; 常用配置加载自定义配置@Component@PropertySource(value = &#123;"classpath:application.yml"&#125;, encoding = "utf-8")public class Config &#123; @Value("$&#123;resources.midpHost&#125;") private String midpHost; public String getMidpHost() &#123; return midpHost; &#125;&#125; 全局异常处理器@ControllerAdvicepublic class GlobalExceptionResolver &#123; Logger logger = LoggerFactory.getLogger(GlobalExceptionResolver.class); @ExceptionHandler(value = Exception.class) @ResponseBody public WebResult exceptionHandle(HttpServletRequest req, Exception ex) &#123; ex.printStackTrace(); logger.error("未知异常", ex); return WebResult.error(ERRORDetail.RC_0401001); &#125;&#125; 示例工程开源地址github]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue封装echarts组件]]></title>
    <url>%2F2017-09-30-vue-echarts%2F</url>
    <content type="text"><![CDATA[说明 做项目的时候为了让数据展示的更加直观，总会用到图表相关的控件，而说到图表控件第一时间当然想到ECharts这个开源项目，而它不像iview、element-ui这些组件使用起来那么便捷，需要绕一个小弯，为了图方便于是对ECharts进行了一层封装 控件演示 控件使用 概要 基于echarts的二次封装 由数据驱动 控件源码见src/components/charts 文档 props 属性 说明 类型 _id 图表唯一标识，当id重复将会报错 String _titleText 图表标题 String _xText x轴描述 String _yText y轴描述 String _chartData 图表数据 Array _type 图表类型，提供三种(LineAndBar/LineOrBar/Pie) String 调用示例 &lt;chart :_id="'testCharts'" :_titleText="'访问量统计'" :_xText="'类别'" :_yText="'总访问量'" :_chartData="chartData" :_type="'Pie'"&gt;&lt;/chart&gt;//测试数据样例 [["类别1",10],["类别2",20]] 实现方式 创建一个待渲染的dom &lt;template&gt; &lt;div :id="_id" class="chart"&gt;&lt;/div&gt;&lt;/template&gt; 绘制函数 function drawPie(chartData,id,titleText,xText,yText) &#123; var chart = echarts.init(document.getElementById(id)) var xAxisData = chartData.map(function (item) &#123;return item[0]&#125;) var pieData = [] chartData.forEach((v,i)=&gt;&#123; pieData.push(&#123; name:v[0], value:v[1] &#125;) &#125;) chart.setOption(&#123; title : &#123; text: titleText, subtext: '', x:'center' &#125;, tooltip : &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)" &#125;, legend: &#123; orient: 'vertical', left: 'left', data: xAxisData &#125;, series : [ &#123; name: xText, type: 'pie', radius : '55%', center: ['50%', '60%'], data:pieData, itemStyle: &#123; emphasis: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' &#125; &#125; &#125; ] &#125;) &#125; 挂载结束、数据源改变时重绘 watch:&#123; _chartData(val)&#123; switch (this._type)&#123; case "LineAndBar": drawLineAndBar(val,this._id,this._titleText,this._xText,this._yText); break case "LineOrBar": drawLineOrBar(val,this._id,this._titleText,this._xText,this._yText); break case "Pie": drawPie(val,this._id,this._titleText,this._xText,this._yText); break default: drawLineAndBar(val,this._id,this._titleText,this._xText,this._yText); break &#125; &#125;&#125;,mounted() &#123; switch (this._type)&#123; case "LineAndBar": drawLineAndBar(this._chartData,this._id,this._titleText,this._xText,this._yText); break case "LineOrBar": drawLineOrBar(this._chartData,this._id,this._titleText,this._xText,this._yText); break case "Pie": drawPie(this._chartData,this._id,this._titleText,this._xText,this._yText); break default: drawLineAndBar(this._chartData,this._id,this._titleText,this._xText,this._yText); break &#125;&#125; 如果觉得有用，欢迎star calebman/vue-DBM]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Element构建自定义树]]></title>
    <url>%2F2017-09-19-vue-custom-tree%2F</url>
    <content type="text"><![CDATA[说明 做项目的时候要使用到一个自定义的树形控件来构建表格树，在github上搜了一下没有搜索到合适的（好看的）可以直接用的，查看Element的组件说明时发现它的Tree控件可以使用render来自定义节点样式，于是基于它封装了一个可以增、删、改的树形组件，现在分享一下它的使用与实现。 控件演示 控件使用 概要 基于element-ui树形控件的二次封装 提供编辑、删除节点的接口 提供一个next钩子，在业务处理失败时可使用next(false)回滚操作 控件源码见 github 文档 props 属性 说明 类型 value 源数据，可使用v-model双向绑定 Array events 事件名 说明 参数 SaveEdit 点击编辑或者添加树节点后的保存事件 (父节点数据、当前节点数据、next) DelNode 删除节点事件 (父节点数据、当前节点数据、next) NodeClick 节点点击事件 (当前节点数据) 源数据描述 属性 说明 value 树节点的唯一标识 label 树节点的显示名称 status (1：编辑状态)(0：显示状态)(-1不可编辑状态) children 子节点数据 调用示例 &lt;m-tree v-model="tableTree" @SaveEdit="SaveEdit" @DelNode="DelNode" @NodeClick="handleNodeClick"&gt;&lt;/m-tree&gt;SaveEdit(parentNode,data,next)&#123; var param = &#123; parentNode:parentNode, node:data &#125; this.$http.post(URL,param).then((response) =&gt; &#123; if(response.status == 200)&#123; next(true,response.body.data.nodeId) &#125;else&#123; next(false) &#125; &#125;)&#125; 实现方式 构建子节点的模板 &lt;span class="span_item"&gt; &lt;span @click="Expanded"&gt; &lt;Input v-if="node.status == 1" style="width: 100px;" v-model="node.label" size="small" &gt;&lt;/Input&gt; &lt;Icon v-if="node.status == 0" type="asterisk"&gt;&lt;/Icon&gt; &lt;Icon v-if="node.status == -1" type="ios-keypad-outline"&gt;&lt;/Icon&gt; &lt;span v-if="node.status != 1"&gt;&#123;&#123;node.label&#125;&#125;&lt;/span&gt; &lt;/span&gt; &lt;span v-if="node.status == 1"&gt; &lt;Button style="margin-left: 8px;" size="small" type="success" icon="checkmark-circled" @click="SaveEdit"&gt;确认&lt;/Button&gt; &lt;Button style="margin-left: 8px;" size="small" type="ghost" icon="checkmark-circled" @click="CancelEdit"&gt;取消&lt;/Button&gt; &lt;/span&gt; &lt;span class="span_icon"&gt; &lt;Icon v-if="node.status == 0" style="margin-left: 8px" color="gray" type="edit" size="16" @click.native="OpenEdit"&gt;&lt;/Icon&gt; &lt;Icon v-if="node.status == 0" style="margin-left: 8px" type="plus-round" color="gray" size="16" @click.native="Append"&gt;&lt;/Icon&gt; &lt;Icon v-if="node.status == 0&amp;&amp;node.children.length &lt; 1" style="margin-left: 8px" type="ios-trash" color="red" size="18" @click.native="Delete"&gt;&lt;/Icon&gt; &lt;/span&gt;&lt;/span&gt; 子节点通过$emit通知父节点事件 SaveEdit()&#123; //保存节点事件 this.$emit('SaveEdit',this.nodeData)&#125;, 父节点核心实现，使用renderContent函数加载子节点模板，点击保存节点时将业务参数保存在runParam中用于在业务操作失败（网络请求失败、服务端异常等情况）的数据回滚 &lt;el-tree class="filter-tree" style="overflow:auto;" :data="treeData" :filter-node-method="filterNode" @node-click="handleNodeClick" ref="tree" node-key="value" :expand-on-click-node="false" :render-content="renderContent" default-expand-all&gt;&lt;/el-tree&gt;//子节点模板renderContent(h, &#123; node, data, store &#125;) &#123; return h(TreeItem,&#123; props:&#123; value:data, treeNode:node &#125;, on:&#123; input:(node)=&gt;&#123; data = node &#125;, Append: () =&gt; &#123; node.expanded = true data.children.push(&#123; value: this.$utilHelper.generateUUID(), label: '请输入模块名称', children: [],status:1,isAdd:true &#125;) &#125;, //保存节点 SaveEdit:(nodeData)=&gt; &#123; //递归查找父节点 var parentNode = this.$utilHelper.getNode(this.treeData,data.value).parentNode this.runParam.parentNode = parentNode this.runParam.data = data this.runParam.nodeData = nodeData this.$emit('SaveEdit',parentNode,data,this.CanSaveNext) &#125; &#125; &#125;) &#125; 操作结果钩子，如果next函数传入false则判定操作失败，使用runParam中的参数进行回滚，该节点的编辑保存操作将无效 CanSaveNext(isNext,nodeId)&#123; let parentNode = this.runParam.parentNode let nodeData = this.runParam.nodeData let data = this.runParam.data if(isNext)&#123; parentNode.children.forEach((v,i)=&gt;&#123; if(v.value == data.value)&#123; if(this.HOST != "static"&amp;&amp;data.isAdd)&#123; data.value = nodeId &#125; data.status = 0 parentNode.children.splice(i,1,data) &#125; &#125;) &#125;else&#123; if(!data.isAdd)&#123; parentNode.children.forEach((v,i)=&gt;&#123; if(v.value == nodeData.value)&#123; data.label = nodeData.label parentNode.children.splice(i,1,data) &#125; &#125;) &#125; &#125; this.runParam = &#123;&#125;&#125; 如果觉得有用，欢迎star calebman/vue-DBM]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vuejs</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
</search>
